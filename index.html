<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¥µé€Ÿå•ç­”æŒ‘æˆ°</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --primary: #6c5ce7;
            --secondary: #a29bfe;
            --success: #00b894;
            --danger: #d63031;
            --bg: #f0f2f5;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }

        #game-container {
            background: white;
            width: 90%;
            max-width: 500px;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            text-align: center;
        }



        .hidden {
            display: none;
        }

        h2 {
            margin-top: 0;
            color: #2d3436;
        }

        /* æŒ‰éˆ•æ¨£å¼ */
        .option-btn {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border: 2px solid #eee;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }

        .option-btn:hover {
            border-color: var(--secondary);
            background: #f9f9ff;
        }

        .option-btn.correct {
            background: var(--success);
            color: white;
            border-color: var(--success);
        }

        .option-btn.wrong {
            background: var(--danger);
            color: white;
            border-color: var(--danger);
        }

        #score-display {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 20px;
        }

        .start-btn {
            padding: 15px 40px;
            font-size: 18px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(108, 92, 231, 0.3);
        }

        .next-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            padding: 15px 30px;
            font-size: 16px;
            background: var(--success);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 184, 148, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
            z-index: 100;
        }

        .next-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 184, 148, 0.5);
        }

        @keyframes blink {
            50% {
                opacity: 0.5;
            }
        }

        /* è§€å¯Ÿè€…æ¨¡å¼æ¨£å¼ */
        .observer-watermark {
            position: fixed;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(108, 92, 231, 0.85);
            color: white;
            padding: 6px 20px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 14px;
            z-index: 200;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(108, 92, 231, 0.3);
            letter-spacing: 2px;
        }

        .observer-mode .option-btn {
            opacity: 0.55;
            cursor: not-allowed;
            pointer-events: none;
        }

        .observer-mode .option-btn:hover {
            border-color: #eee;
            background: white;
        }

        .observe-btn {
            width: auto;
            margin: 0;
            background: #636e72 !important;
            color: white;
            border: none;
            font-size: 14px;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <div id="start-screen">
            <h1>âš¡ æ¥µé€Ÿå•ç­” âš¡</h1>
            <p>ç­”é¡Œè¶Šå¿«ï¼Œåˆ†æ•¸è¶Šé«˜ï¼</p>

            <div id="lobby-ui"
                style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 10px; border: 1px solid #e9ecef;">
                <div id="connection-status" style="margin-bottom: 15px; font-weight: bold; color: #636e72;">å–®æ©Ÿæ¨¡å¼</div>

                <div style="margin-bottom: 15px;">
                    <label
                        style="display:block; text-align:left; font-weight:bold; color:#2d3436; margin-bottom:5px;">æ‚¨çš„æš±ç¨±</label>
                    <input type="text" id="player-name-input" placeholder="è¼¸å…¥æ‚¨çš„æš±ç¨±" value="ç©å®¶"
                        style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; box-sizing: border-box;">
                </div>

                <div id="host-controls">
                    <button class="option-btn" onclick="initHost()"
                        style="background:var(--secondary); color:#fff; border:none;">ğŸ  å»ºç«‹æˆ¿é–“ (ç”¢ç”Ÿé‚€è«‹ç¢¼)</button>
                    <label id="host-spectate-label" class="hidden"
                        style="display:none; align-items:center; gap:6px; margin-top:10px; font-weight:bold; color:#636e72; cursor:pointer;">
                        <input type="checkbox" id="host-spectate-check"
                            style="width:18px; height:18px; cursor:pointer;"> ğŸ‘ æˆ¿ä¸»è§€æˆ°ï¼ˆä¸åƒèˆ‡ä½œç­”ï¼‰
                    </label>
                    <div id="invite-code-display" class="hidden"
                        style="margin-top:10px; padding:10px; background:#e1ffc7; border-radius:5px; font-weight:bold;">
                        é‚€è«‹ç¢¼: <span id="my-peer-id" style="color:#d63031; font-size:1.2em; user-select: all;">...</span>
                    </div>
                </div>

                <div id="join-controls" style="margin-top: 10px;">
                    <div style="display:flex; gap:5px;">
                        <input type="text" id="target-peer-id" placeholder="è¼¸å…¥é‚€è«‹ç¢¼"
                            style="flex:1; padding:10px; border:1px solid #ddd; border-radius:5px;">
                        <button class="option-btn" onclick="joinGame()"
                            style="width: auto; margin:0; background: #00b894; color: white;">åŠ å…¥</button>
                        <button class="option-btn observe-btn" onclick="joinAsObserver()">ğŸ‘ è§€å¯Ÿ</button>
                    </div>
                </div>
            </div>

            <button class="start-btn" id="start-game-btn" onclick="tryStartGame()">é–‹å§‹æŒ‘æˆ°</button>

            <div style="margin-top: 25px; text-align: center;">
                <p style="font-weight: bold; color: #2d3436; margin-bottom: 10px;">ğŸ“± æƒæ QR Code åŠ å…¥éŠæˆ²</p>
                <img src="https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=https://20211013louis-cmd.github.io/"
                    alt="éŠæˆ² QR Code"
                    style="border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); width: 200px; height: 200px;">
                <p style="font-size: 12px; color: #999; margin-top: 8px;">https://20211013louis-cmd.github.io/</p>
            </div>

            <div style="margin-top: 20px;">
                <a href="admin.html" style="color: #999; text-decoration: none; font-size: 14px;">âš™ï¸ ç®¡ç†é¡Œåº«</a>
            </div>
        </div>

        <div id="quiz-screen" class="hidden">
            <div id="header-row"
                style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <div id="question-info" style="font-weight: bold;">ç¬¬ <span id="current-idx">1</span> é¡Œ</div>
                <div id="live-score" style="color: var(--primary); font-weight: bold;">ç›®å‰åˆ†æ•¸ï¼š0</div>
            </div>
            <div id="img-container" style="text-align: center; margin: 10px 0; min-height: 0px;"></div>
            <h2 id="question-text">è¼‰å…¥ä¸­...</h2>
            <div id="options-container"></div>
            <div id="waiting-msg" class="hidden"
                style="margin-top:10px; color:#e17055; font-weight:bold; animation: blink 1s infinite;">ç­‰å¾…å°æ‰‹å›ç­”...</div>
            <button id="reveal-btn" class="next-btn hidden" onclick="hostReveal()"
                style="left:30px; right:auto; background:#d63031;">âœ‹ çµæŸä½œç­”</button>
            <button id="next-btn" class="next-btn hidden" onclick="nextQuestion()">ä¸‹ä¸€é¡Œ âœ</button>
        </div>

        <div id="result-screen" class="hidden">
            <h2>ğŸ† æŒ‘æˆ°çµæŸï¼</h2>
            <div id="score-display">å¾—åˆ†ï¼š0</div>

            <!-- Ranking Section -->
            <div id="ranking-container" class="hidden"
                style="margin-bottom:20px; text-align:left; background:#f0f2f5; padding:15px; border-radius:10px;">
                <h3 style="margin-top:0; text-align:center;">æ’è¡Œæ¦œ</h3>
                <div id="rank-list"></div>
            </div>

            <button class="start-btn" onclick="location.reload()">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

    <script>
        const defaultQuestions = [
            { q: "å°ç£æœ€é«˜çš„å±±æ˜¯å“ªä¸€åº§ï¼Ÿ", a: ["ç‰å±±", "é›ªå±±", "å¤§éœ¸å°–å±±", "é˜¿é‡Œå±±"], correct: 0 },
            { q: "HTML ä¸­å“ªå€‹æ¨™ç±¤æ˜¯ç”¨ä¾†é€£çµ JavaScriptï¼Ÿ", a: ["<link>", "<js>", "<script>", "<href>"], correct: 2 },
            { q: "å¤ªé™½ç³»ä¸­é«”ç©æœ€å¤§çš„è¡Œæ˜Ÿæ˜¯ï¼Ÿ", a: ["åœ°çƒ", "ç«æ˜Ÿ", "æœ¨æ˜Ÿ", "åœŸæ˜Ÿ"], correct: 2 },
            { q: "éŠæˆ²é–‹ç™¼ä¸­ï¼ŒNPC ä»£è¡¨ä»€éº¼ï¼Ÿ", a: ["æ–°ç©å®¶è§’è‰²", "éç©å®¶è§’è‰²", "ä¸»è¦é ˜è¢–è§’è‰²", "æ ¸èƒ½ä¸­å¿ƒ"], correct: 1 }
        ];

        // å„ªå…ˆè®€å– localStorage è¨­å®šï¼Œè‹¥ç„¡å‰‡ä½¿ç”¨é è¨­å€¼
        let questions = JSON.parse(localStorage.getItem('quiz_questions')) || defaultQuestions;

        // Multiplayer logic
        let peer = null;
        let conn = null; // Client: Connection to Host
        let connections = []; // Host: Array of connections to Clients
        let isHost = false;
        let isMultiplayer = false;
        let isObserver = false; // è§€å¯Ÿè€…æ¨¡å¼

        // Host: Player States
        // { peerId: { name: "Player N", score: 0, ready: false, answers: {} } }
        let players = {};

        // Host: Observer States
        let observers = {};

        // Sync State
        let myReady = false;
        let oppReady = false;

        function initHost() {
            const id = Math.floor(Math.random() * 9000 + 1000).toString(); // 4-digit ID
            peer = new Peer(id);
            peer.on('open', (id) => {
                document.getElementById('my-peer-id').innerText = id;
                document.getElementById('invite-code-display').classList.remove('hidden');
                updatePlayerCountUI(); // Update UI
                document.getElementById('connection-status').innerText = "ç­‰å¾…ç©å®¶åŠ å…¥...";
                document.getElementById('join-controls').classList.add('hidden');
                isHost = true;
                isMultiplayer = true;

                // é¡¯ç¤ºè§€æˆ°å‹¾é¸æ¡†
                const spectateLabel = document.getElementById('host-spectate-label');
                spectateLabel.classList.remove('hidden');
                spectateLabel.style.display = 'flex';

                // Host ä¹Ÿè¦ç®—ä½œä¸€å€‹ç©å®¶
                const myName = document.getElementById('player-name-input').value.trim() || "æˆ¿ä¸»";
                players['host'] = { name: myName, score: 0, ready: false, isHost: true };

                // é–å®šæš±ç¨±
                const nameInput = document.getElementById('player-name-input');
                nameInput.disabled = true;
                nameInput.style.background = '#e9ecef';
                nameInput.style.cursor = 'not-allowed';
            });
            peer.on('connection', (c) => {
                connections.push(c);
                console.log("New connection:", c.peer);
                setupHostConnection(c);

                const isObserverPeer = c.metadata && c.metadata.role === 'observer';

                if (isObserverPeer) {
                    // è§€å¯Ÿè€…ï¼šä¸åŠ å…¥ players
                    const obsName = c.metadata.name || `è§€å¯Ÿè€… ${Object.keys(observers).length + 1}`;
                    observers[c.peer] = { name: obsName };
                } else {
                    // ç©å®¶
                    const guestName = c.metadata && c.metadata.name ? c.metadata.name : `ç©å®¶ ${connections.length}`;
                    players[c.peer] = { name: guestName, score: 0, ready: false };
                }
                updatePlayerCountUI();

                // Send current state or welcome
                c.on('open', () => {
                    c.send({ type: 'WELCOME', questions: questions, yourId: c.peer, role: isObserverPeer ? 'observer' : 'player' });
                });
            });
            peer.on('error', (err) => {
                if (err.type === 'unavailable-id') initHost(); // Retry if ID collision
                else alert("é€£ç·šéŒ¯èª¤: " + err);
            });
        }

        // Host handles connection from a client
        function setupHostConnection(c) {
            c.on('data', (data) => {
                handleData(data, c.peer); // Pass peerId to handleData
            });
            c.on('close', () => {
                console.log("Connection closed:", c.peer);
                connections = connections.filter(conn => conn !== c);
                if (observers[c.peer]) {
                    delete observers[c.peer];
                } else {
                    delete players[c.peer];
                    // If a player leaves, check if we can proceed
                    checkAllAnswered();
                }
                updatePlayerCountUI();
            });
        }

        function updatePlayerCountUI() {
            const playerCount = Object.keys(players).length;
            const observerCount = Object.keys(observers).length;
            let text = `ç©å®¶: ${playerCount} äºº`;
            if (observerCount > 0) text += ` | è§€å¯Ÿè€…: ${observerCount} äºº`;
            document.getElementById('connection-status').innerText = text;
        }

        // Client connects to Host
        function joinGame() {
            const targetId = document.getElementById('target-peer-id').value.trim();
            if (!targetId) return alert("è«‹è¼¸å…¥é‚€è«‹ç¢¼");

            const myName = document.getElementById('player-name-input').value.trim() || "ç©å®¶";

            // é–å®šæš±ç¨±
            const nameInput = document.getElementById('player-name-input');
            nameInput.disabled = true;
            nameInput.style.background = '#e9ecef';
            nameInput.style.cursor = 'not-allowed';

            peer = new Peer();
            peer.on('open', () => {
                // Send metadata with name
                conn = peer.connect(targetId, { metadata: { name: myName } });
                isMultiplayer = true;
                setupClientConnection();
                document.getElementById('connection-status').innerText = "é€£ç·šä¸­...";
            });
            peer.on('error', (err) => alert("é€£ç·šå¤±æ•—ï¼Œè«‹æª¢æŸ¥é‚€è«‹ç¢¼"));
        }

        // è§€å¯Ÿè€…åŠ å…¥
        function joinAsObserver() {
            const targetId = document.getElementById('target-peer-id').value.trim();
            if (!targetId) return alert("è«‹è¼¸å…¥é‚€è«‹ç¢¼");

            const myName = document.getElementById('player-name-input').value.trim() || "è§€å¯Ÿè€…";

            // é–å®šæš±ç¨±
            const nameInput = document.getElementById('player-name-input');
            nameInput.disabled = true;
            nameInput.style.background = '#e9ecef';
            nameInput.style.cursor = 'not-allowed';

            peer = new Peer();
            peer.on('open', () => {
                conn = peer.connect(targetId, { metadata: { name: myName, role: 'observer' } });
                isMultiplayer = true;
                isObserver = true;
                setupClientConnection();
                document.getElementById('connection-status').innerText = "è§€å¯Ÿè€…é€£ç·šä¸­...";
            });
            peer.on('error', (err) => alert("é€£ç·šå¤±æ•—ï¼Œè«‹æª¢æŸ¥é‚€è«‹ç¢¼"));
        }

        function setupClientConnection() {
            // è¨­å®š data ç›£è½å™¨
            conn.on('data', (data) => {
                handleData(data);
            });

            conn.on('open', () => {
                console.log("Connected to Host");
                if (isObserver) {
                    document.getElementById('connection-status').innerText = "ğŸ‘ è§€å¯Ÿè€…å·²é€£ç·šï¼ç­‰å¾…æˆ¿ä¸»é–‹å§‹";
                } else {
                    document.getElementById('connection-status').innerText = "å·²é€£ç·šï¼ç­‰å¾…æˆ¿ä¸»é–‹å§‹";
                }
                document.getElementById('start-game-btn').classList.add('hidden');
                document.getElementById('host-controls').classList.add('hidden');
            });
        }

        function broadcast(data) {
            connections.forEach(c => {
                if (c.open) c.send(data);
            });
        }

        function handleData(data, peerId = null) {
            console.log("Received data:", data, "from:", peerId);

            if (isHost) {
                // å¿½ç•¥è§€å¯Ÿè€…çš„éŠæˆ²è¨Šæ¯
                if (observers[peerId]) return;

                // Host Logic
                if (data.type === 'QUESTION_ANSWERED') {
                    if (players[peerId]) {
                        players[peerId].ready = true;
                        checkAllAnswered();
                    }
                } else if (data.type === 'SCORE_UPDATE') {
                    if (players[peerId]) {
                        players[peerId].score = data.score;
                    }
                } else if (data.type === 'GAME_OVER') {
                    if (players[peerId]) {
                        players[peerId].score = data.score;
                    }
                }
            } else {
                // Client Logic
                if (data.type === 'WELCOME') {
                    if (data.questions) questions = data.questions;
                    // Optional: store my ID if needed: data.yourId
                } else if (data.type === 'START_GAME') {
                    if (data.questions) questions = data.questions;
                    startGame(true);
                } else if (data.type === 'NEXT_QUESTION') {
                    goToNextQuestion();
                } else if (data.type === 'REVEAL_ANSWER') {
                    revealAnswer(); // Host says time's up or everyone answered
                } else if (data.type === 'GAME_OVER') {
                    if (data.ranking) {
                        updateRankingList(data.ranking);
                    }
                    endGame(true); // true = remote
                } else if (data.type === 'UPDATE_RANKING') {
                    // Update ranking UI (Optional, if we do live ranking)
                    updateRankingList(data.ranking);
                }
            }
        }

        function tryStartGame() {
            if (isMultiplayer && isHost) {
                // æª¢æŸ¥æˆ¿ä¸»æ˜¯å¦é¸æ“‡è§€æˆ°
                if (document.getElementById('host-spectate-check').checked) {
                    isObserver = true;
                    delete players['host']; // æˆ¿ä¸»ä¸è¨ˆå…¥ç©å®¶
                    updatePlayerCountUI();
                }
                // Broadcast start
                broadcast({ type: 'START_GAME', questions: questions });
                startGame();
            } else if (isMultiplayer && !isHost) {
                // Guest waiting
            } else {
                // Single player
                startGame();
            }
        }

        let currentIdx = 0;
        let score = 0;

        function startGame(isRemote = false) {
            if (document.getElementById('start-screen').classList.contains('hidden')) return; // Avoid double start
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('quiz-screen').classList.remove('hidden');

            // è§€å¯Ÿè€…æ¨¡å¼ï¼šåŠ ä¸Šæµ®æ°´å°èˆ‡ç¦ç”¨ class
            if (isObserver) {
                document.getElementById('quiz-screen').classList.add('observer-mode');
                // æ–°å¢æµ®æ°´å°
                const wm = document.createElement('div');
                wm.className = 'observer-watermark';
                wm.id = 'observer-wm';
                wm.innerText = 'ğŸ‘ è§€å¯Ÿæ¨¡å¼';
                document.body.appendChild(wm);
                // éš±è—åˆ†æ•¸
                document.getElementById('live-score').style.display = 'none';
            }

            loadQuestion();
        }

        function loadQuestion() {
            if (currentIdx >= questions.length) {
                endGame();
                return;
            }

            // Reset Round State
            if (isHost) {
                // Reset all players ready state
                Object.keys(players).forEach(pid => players[pid].ready = false);
            }

            // é‡ç½®ç©å®¶é¸æ“‡
            playerSelection = { index: -1, btn: null };
            document.getElementById('waiting-msg').classList.add('hidden');
            document.getElementById('options-container').classList.remove('disabled-area');
            document.getElementById('next-btn').classList.add('hidden');
            // å¤šäººæ¨¡å¼æˆ¿ä¸»é¡¯ç¤ºã€ŒçµæŸä½œç­”ã€æŒ‰éˆ•
            if (isMultiplayer && isHost) {
                document.getElementById('reveal-btn').classList.remove('hidden');
            }

            const q = questions[currentIdx];
            document.getElementById('question-text').innerText = q.q;
            document.getElementById('current-idx').innerText = currentIdx + 1;

            // é¡¯ç¤ºåœ–ç‰‡
            const imgContainer = document.getElementById('img-container');
            if (q.image && q.image.trim() !== "") {
                imgContainer.innerHTML = `<img src="${q.image}" style="max-width: 100%; max-height: 250px; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.1);">`;
                imgContainer.classList.remove('hidden');
            } else {
                imgContainer.innerHTML = '';
                imgContainer.classList.add('hidden'); // Hide if no image
            }

            // æº–å‚™ç´¢å¼•ä¸¦æ‰“äº‚
            let indices = q.a.map((_, i) => i);
            indices.sort(() => Math.random() - 0.5);

            const container = document.getElementById('options-container');
            container.innerHTML = '';

            indices.forEach((originalIndex) => {
                const btn = document.createElement('button');
                btn.className = 'option-btn';
                btn.innerText = q.a[originalIndex];
                btn.dataset.originalIndex = originalIndex; // å„²å­˜åŸå§‹ç´¢å¼•ä»¥ä¾¿æ ¸å°
                btn.onclick = () => selectAnswer(originalIndex, btn);
                container.appendChild(btn);
            });
        }

        function updateScoreDisplay() {
            document.getElementById('live-score').innerText = `ç›®å‰åˆ†æ•¸ï¼š${score}`;
            if (isMultiplayer) {
                if (isHost) {
                    players['host'].score = score;
                } else {
                    if (conn && conn.open) conn.send({ type: 'SCORE_UPDATE', score: score });
                }
            }
        }

        // å„²å­˜ç©å®¶é¸æ“‡
        let playerSelection = { index: -1, btn: null };

        function selectAnswer(selectedOriginalIndex, selectedBtn) {
            // è§€å¯Ÿè€…ä¸èƒ½ä½œç­”
            if (isObserver) return;
            // å¦‚æœå·²ç¶“é¸éï¼Œå¿½ç•¥
            if (playerSelection.index !== -1) return;

            // è¨˜éŒ„é¸æ“‡
            playerSelection = {
                index: selectedOriginalIndex,
                btn: selectedBtn
            };

            // ç¦ç”¨æ‰€æœ‰æŒ‰éˆ•
            const btns = document.querySelectorAll('.option-btn');
            btns.forEach(btn => btn.disabled = true);

            // æ¨™è¨˜å·²é¸æ“‡çš„æŒ‰éˆ•ï¼ˆæ·ºè‰²æç¤ºï¼‰
            if (selectedBtn) {
                selectedBtn.style.background = '#dfe6e9';
                selectedBtn.style.borderColor = '#b2bec3';
            }

            // é¡¯ç¤ºç­‰å¾…è¨Šæ¯
            if (!isObserver) {
                document.getElementById('waiting-msg').innerText = "å·²ä½œç­”ï¼Œç­‰å¾…å…¶ä»–ç©å®¶...";
                document.getElementById('waiting-msg').classList.remove('hidden');
            }

            // å¤šäººæ¨¡å¼åŒæ­¥
            if (isMultiplayer) {
                if (isHost) {
                    players['host'].ready = true;
                    checkAllAnswered();
                } else {
                    conn.send({ type: 'QUESTION_ANSWERED', round: currentIdx });
                }
            } else {
                // å–®äººæ¨¡å¼ï¼šç›´æ¥æ­æ›‰ç­”æ¡ˆ
                revealAnswer();
            }
        }

        function checkAllAnswered() {
            // ä¸å†è‡ªå‹•æ­æ›‰ï¼Œç”±æˆ¿ä¸»æ‰‹å‹•æŒ‰ã€ŒçµæŸä½œç­”ã€
        }

        // æˆ¿ä¸»æ‰‹å‹•çµæŸä½œç­”
        function hostReveal() {
            if (!isHost) return;
            broadcast({ type: 'REVEAL_ANSWER' });
            document.getElementById('reveal-btn').classList.add('hidden');
            revealAnswer();
        }

        function revealAnswer() {
            const q = questions[currentIdx];
            const btns = document.querySelectorAll('.option-btn');

            // ç¢ºä¿æŒ‰éˆ•å·²ç¦ç”¨
            btns.forEach(btn => btn.disabled = true);

            // æ¸…é™¤æ·ºè‰²æç¤ºï¼Œæ¢å¾©åŸæ¨£
            btns.forEach(btn => {
                btn.style.background = '';
                btn.style.borderColor = '';
            });

            // é¡¯ç¤ºçµæœ
            if (playerSelection.index === q.correct) {
                if (playerSelection.btn) playerSelection.btn.classList.add('correct');
                score += 10; // ç­”å°å¾— 10 åˆ†
                updateScoreDisplay();
            } else {
                if (playerSelection.btn) playerSelection.btn.classList.add('wrong');
                // é¡¯ç¤ºæ­£ç¢ºç­”æ¡ˆ
                const correctBtn = Array.from(btns).find(btn => parseInt(btn.dataset.originalIndex) === q.correct);
                if (correctBtn) correctBtn.classList.add('correct');
            }

            // éš±è—ç­‰å¾…è¨Šæ¯
            document.getElementById('waiting-msg').classList.add('hidden');

            // é¡¯ç¤ºã€Œä¸‹ä¸€é¡Œã€æŒ‰éˆ•ï¼ˆå¤šäººæ¨¡å¼åªæœ‰æˆ¿ä¸»å¯ä»¥æŒ‰ï¼‰
            if (isHost) {
                document.getElementById('next-btn').classList.remove('hidden');
            } else if (isMultiplayer) {
                // éæˆ¿ä¸»ç­‰å¾…æˆ¿ä¸»æŒ‰ä¸‹ä¸€é¡Œ
                document.getElementById('waiting-msg').innerText = "ç­‰å¾…æˆ¿ä¸»é€²å…¥ä¸‹ä¸€é¡Œ...";
                document.getElementById('waiting-msg').classList.remove('hidden');
                document.getElementById('next-btn').classList.add('hidden');
            } else {
                document.getElementById('next-btn').classList.remove('hidden');
            }
        }



        function checkSyncNext() {
            if (myReady && oppReady) {
                setTimeout(nextQuestion, 500); // Short delay to see status
            }
        }

        function nextQuestion() {
            // å¤šäººæ¨¡å¼ä¸‹ï¼Œæˆ¿ä¸»é€šçŸ¥å®¢äººè·³ä¸‹ä¸€é¡Œ
            if (isMultiplayer && isHost) {
                broadcast({ type: 'NEXT_QUESTION' });
            }
            goToNextQuestion();
        }

        function goToNextQuestion() {
            // éš±è—ä¸‹ä¸€é¡ŒæŒ‰éˆ•
            document.getElementById('next-btn').classList.add('hidden');
            document.getElementById('waiting-msg').classList.add('hidden');
            currentIdx++;
            loadQuestion();
        }

        function endGame(isRemote = false) {
            document.getElementById('quiz-screen').classList.add('hidden');
            document.getElementById('result-screen').classList.remove('hidden');

            // ç§»é™¤è§€å¯Ÿè€…æµ®æ°´å°
            const wm = document.getElementById('observer-wm');
            if (wm) wm.remove();

            if (isObserver) {
                document.getElementById('score-display').innerText = 'è§€å¯Ÿæ¨¡å¼';
            } else {
                document.getElementById('score-display').innerText = `æœ€çµ‚å¾—åˆ†ï¼š${score}`;
            }

            if (isMultiplayer) {
                document.getElementById('ranking-container').classList.remove('hidden');

                if (isHost && !isRemote) {
                    // Host calculates ranking
                    let ranking = Object.values(players).map(p => ({
                        name: p.name,
                        score: p.score,
                        isHost: p.isHost
                    }));

                    // Sort descending
                    ranking.sort((a, b) => b.score - a.score);

                    // Broadcast
                    broadcast({ type: 'GAME_OVER', ranking: ranking });

                    // Show locally
                    updateRankingList(ranking);
                }
                // Client / Observer waits for GAME_OVER message with ranking
            } else {
                document.getElementById('ranking-container').classList.add('hidden');
            }
        }

        // Helper to update ranking UI
        function updateRankingList(ranking) {
            const list = document.getElementById('rank-list');
            let html = '';

            ranking.forEach((p, index) => {
                let rankIcon = index === 0 ? "ğŸ¥‡" : (index === 1 ? "ğŸ¥ˆ" : (index === 2 ? "ğŸ¥‰" : `#${index + 1}`));
                let color = index === 0 ? "#d63031" : (index === 1 ? "#e17055" : "#636e72");
                // Highlight self if possible? For now, just show names
                // If I am host, I know "æˆ¿ä¸» (æˆ‘)"

                html += `
                    <div style="display:flex; justify-content:space-between; padding:10px; border-bottom:1px solid #eee; color:${color}; font-weight:bold;">
                        <span>${rankIcon} ${p.name}</span>
                        <span>${p.score} åˆ†</span>
                    </div>
                `;
            });

            list.innerHTML = html;
        }
    </script>

</body>

</html>